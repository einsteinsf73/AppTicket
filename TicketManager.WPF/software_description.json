{
  "project": "TicketManager.WPF",
  "summary": {
    "source_file": "software_description.json",
    "source_file_citation": "fileciteturn0file0",
    "brief": "Recomendações técnicas e de produto para TicketManager.WPF (WPF desktop + Oracle + EF Core) focadas em arquitetura, desempenho, segurança, UX, testes e operações."
  },
  "findings": [
    {
      "id": "F01",
      "area": "Arquitetura & Padrões",
      "issue": "Código WPF pode estar diretamente acoplado a code-behind; risco de dificuldade para testar e manter.",
      "evidence": [
        "MainWindow.xaml",
        "TicketWindow.xaml",
        "TicketWindow.xaml.cs"
      ]
    },
    {
      "id": "F02",
      "area": "Banco de Dados & EF Core (Oracle)",
      "issue": "Uso de EF Core com Oracle precisa atenção a tipos, transações e performance (N+1, consultas geradas).",
      "evidence": [
        "Migrations/*",
        "InitialOracleCreate"
      ]
    },
    {
      "id": "F03",
      "area": "Concorrência & SLA",
      "issue": "Regras de SLA e reabertura podem ter condições de concorrência (ex.: dois operadores alterando um ticket).",
      "evidence": [
        "Migrations/20251013143103_AddSLAFinal.cs",
        "ReopeningLog"
      ]
    },
    {
      "id": "F04",
      "area": "Segurança",
      "issue": "Configurações em appsettings.json podem conter connection strings sensíveis; controle mínimo de privilégios indicado.",
      "evidence": [
        "appsettings.json",
        "AuthorizedUser.cs"
      ]
    },
    {
      "id": "F05",
      "area": "Observabilidade & Logs",
      "issue": "Modelo de logs existente (TicketLog, ReopeningLog) é bom, mas não há indicação de centralização, correlação ou níveis estruturados.",
      "evidence": [
        "Models/TicketLog.cs",
        "Models/ReopeningLog.cs"
      ]
    }
  ],
  "recommendations": [
    {
      "id": "R01",
      "title": "Adotar MVVM estrito e injeção de dependência",
      "priority": "high",
      "effort": "medium",
      "details": "Extrair lógica de UI para ViewModels, usar ICommand e Bindings, e aplicar um container DI (Microsoft.Extensions.DependencyInjection or Autofac). Reduz o code-behind e facilita testes unitários.",
      "why": "Melhora testabilidade e separação de responsabilidades."
    },
    {
      "id": "R02",
      "title": "Introduzir camadas: Application / Domain / Infrastructure",
      "priority": "high",
      "effort": "medium",
      "details": "Criar projetos separados (ex.: TicketManager.Core, TicketManager.Application, TicketManager.Infrastructure, TicketManager.UI). Definir interfaces para repositórios e serviços; manter EF Core apenas na camada Infrastructure.",
      "why": "Permite trocas tecnológicas, testes de unidade com mocks e reduz acoplamento."
    },
    {
      "id": "R03",
      "title": "Melhorar o uso do EF Core com Oracle",
      "priority": "high",
      "effort": "medium",
      "details": [
        "Use consultas projetadas (Select new { ... }) para evitar carregamento desnecessário e o problema N+1.",
        "Habilite e revise logs de SQL gerado para detectar consultas lentas.",
        "Considere configuração de CommandTimeout, conexões em pool e uso de Stored Procedures para operações pesadas.",
        "Implemente índices e analise planos de execução para consultas críticas (search by status, ticket owner, SLA)."
      ],
      "why": "Performance e previsibilidade em produção com Oracle."
    },
    {
      "id": "R04",
      "title": "Garantir integridade concorrente (otimistic concurrency)",
      "priority": "high",
      "effort": "low",
      "details": "Adicionar um campo RowVersion / ConcurrencyToken (byte[]/timestamp) no modelo Ticket; tratar DbUpdateConcurrencyException para informar o usuário e mesclar alterações quando apropriado.",
      "why": "Evita perda de alterações quando múltiplos usuários editam o mesmo ticket."
    },
    {
      "id": "R05",
      "title": "Centralizar logs e telemetria",
      "priority": "medium",
      "effort": "low",
      "details": [
        "Adote logging estruturado (Microsoft.Extensions.Logging + Serilog) com sinks para arquivo, ELK/Elastic/Seq ou Azure Application Insights.",
        "Inclua correlações (RequestId / OperationId) quando ações do usuário alterarem tickets.",
        "Expanda logs existentes (TicketLog) com metadados (userId, machine, version)."
      ],
      "why": "Facilita troubleshooting, SLA enforcement e auditoria."
    },
    {
      "id": "R06",
      "title": "Segurança: segredos e princípio do menor privilégio",
      "priority": "high",
      "effort": "low",
      "details": [
        "Remover connection strings sensíveis de appsettings.json em produção; usar Secret Manager em dev e um vault (Azure Key Vault, HashiCorp Vault) em produção.",
        "Use accounts de banco com privilégio mínimo (apenas CRUD nas tabelas necessárias).",
        "Habilite criptografia em repouso e em trânsito (TNS/SSL para Oracle)."
      ],
      "why": "Reduz vetor de ataque e exposição de dados."
    },
    {
      "id": "R07",
      "title": "Automatizar testes (unitários e integração) e CI",
      "priority": "high",
      "effort": "medium",
      "details": [
        "Criar suites de teste: ViewModel unit tests (xUnit/NUnit), Integration tests para repositórios usando Oracle in-memory test or test container.",
        "Adicionar pipeline CI (GitHub Actions / Azure DevOps) com build, testes e análise estática (SonarCloud)."
      ],
      "why": "Melhora qualidade do código e detecta regressões cedo."
    },
    {
      "id": "R08",
      "title": "Refinar UX e acessibilidade",
      "priority": "medium",
      "effort": "low",
      "details": [
        "Melhorar filtros e busca (full-text search where possible), paginação virtualizada em listas longas, destaque de SLA iminente com cores e notificações.",
        "Suporte a atalhos de teclado, contrastes e leitores de tela (automation properties)."
      ],
      "why": "Maior eficiência dos operadores e conformidade com acessibilidade."
    },
    {
      "id": "R09",
      "title": "Notificações e automações de SLA",
      "priority": "medium",
      "effort": "medium",
      "details": [
        "Criar serviço de background (Windows Service ou agendador) que verifique SLAs expirando e envie notificações (email, webhook, push interno).",
        "Adicionar triggers para ações automáticas (escalonamento) quando SLA for violado."
      ],
      "why": "Reduz violação de SLA e melhora resposta operacional."
    },
    {
      "id": "R10",
      "title": "Melhorar modelagem de logs e histórico",
      "priority": "medium",
      "effort": "low",
      "details": [
        "Normalizar o esquema de TicketLog: ações, campos alterados (old/new), timestamp, userId, correlationId.",
        "Armazenar dumps de payloads (JSON) quando necessário para reconstruir estados."
      ],
      "why": "Auditoria completa e mais fácil investigação."
    },
    {
      "id": "R11",
      "title": "Política de migrações e deploy de schema",
      "priority": "medium",
      "effort": "low",
      "details": [
        "Automatizar migrações no CI com checagens; usar versão controlada do DDL; em Oracle, coordene deploys com DBAs para índices/particionamento."
      ],
      "why": "Evita inconsistências entre ambientes e downtime inesperado."
    },
    {
      "id": "R12",
      "title": "Melhorias na configuração e operações",
      "priority": "low",
      "effort": "low",
      "details": [
        "Adicionar health-check endpoints (se expor API) ou health pages internas.",
        "Implementar backup/restore e plano de retenção de logs e dados."
      ],
      "why": "Operações mais confiáveis e previsíveis."
    }
  ],
  "quick_wins": [
    "Integrate Serilog with rolling file sink and include application version in logs.",
    "Add RowVersion concurrency token to Ticket model and create/coordinate migration with DBA.",
    "Add ViewModelBase and move simple code-behind actions to ViewModels using RelayCommand.",
    "Adicionar RowVersion concurrency token ao Ticket.",
    "Habilitar Serilog (arquivo rotativo) e incluir versão da aplicação nos logs.",
    "Criar ViewModel base e mover comandos do code-behind para lá.",
    "Ativar logging SQL do EF Core em ambiente de staging para localizar N+1."
  ],
  "further_notes": [
    "As recomendações foram geradas com base no resumo do projeto contido em software_description.json. Para recomendações mais precisas e código de exemplo, fornecer o repositório completo permitiria análise estática e sugestões alvo (e.g., trechos de código, queries exatas a otimizar).",
    "Citaram-se práticas que equilibram segurança, desempenho e manutenibilidade sem prescrever mudanças irreversíveis."
  ],
  "source": "fileciteturn0file0",
  "codeExamples": [
    {
      "id": "C01",
      "title": "ViewModelBase + RelayCommand (WPF, C#)",
      "filename": "ViewModels/ViewModelBase.cs",
      "language": "csharp",
      "snippet": "using System;\nusing System.ComponentModel;\nusing System.Runtime.CompilerServices;\nusing System.Windows.Input;\n\nnamespace TicketManager.ViewModels\n{\n    public abstract class ViewModelBase : INotifyPropertyChanged\n    {\n        public event PropertyChangedEventHandler PropertyChanged;\n\n        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)\n        {\n            if (Equals(storage, value)) return false;\n            storage = value;\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n\n        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)\n            => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n    }\n\n    public class RelayCommand : ICommand\n    {\n        private readonly Action<object> _execute;\n        private readonly Func<object, bool> _canExecute;\n\n        public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)\n        {\n            _execute = execute ?? throw new ArgumentNullException(nameof(execute));\n            _canExecute = canExecute;\n        }\n\n        public bool CanExecute(object parameter) => _canExecute?.Invoke(parameter) ?? true;\n\n        public void Execute(object parameter) => _execute(parameter);\n\n        public event EventHandler CanExecuteChanged;\n        public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);\n    }\n}"
    },
    {
      "id": "C02",
      "title": "Example ViewModel: TicketViewModel (using ViewModelBase and RelayCommand)",
      "filename": "ViewModels/TicketViewModel.cs",
      "language": "csharp",
      "snippet": "using System.Threading.Tasks;\nusing System.Windows;\nusing TicketManager.Models;\nusing TicketManager.Services;\n\nnamespace TicketManager.ViewModels\n{\n    public class TicketViewModel : ViewModelBase\n    {\n        private readonly ITicketService _ticketService;\n\n        public TicketViewModel(ITicketService ticketService)\n        {\n            _ticketService = ticketService;\n            OpenTicketCommand = new RelayCommand(async _ => await OpenTicketAsync(), _ => SelectedTicket != null);\n        }\n\n        private Ticket _selectedTicket;\n        public Ticket SelectedTicket\n        {\n            get => _selectedTicket;\n            set\n            {\n                if (SetProperty(ref _selectedTicket, value))\n                {\n                    ((RelayCommand)OpenTicketCommand).RaiseCanExecuteChanged();\n                }\n            }\n        }\n\n        public ICommand OpenTicketCommand { get; }\n\n        private async Task OpenTicketAsync()\n        {\n            // move code-behind actions here\n            var ticket = await _ticketService.GetByIdAsync(SelectedTicket.Id);\n            // show details in a bound dialog or view\n            MessageBox.Show($\"Ticket {ticket.Id} opened by {ticket.Owner}\");\n        }\n    }"
    },
    {
      "id": "C03",
      "title": "EF Core: RowVersion / Concurrency Token (Model + Migration example)",
      "filename": "Models/Ticket.cs (+ Migrations)",
      "language": "csharp",
      "snippet": "// Model (Ticket.cs)\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\npublic class Ticket\n{\n    public int Id { get; set; }\n    // ... other properties ...\n\n    // Preferred: concurrency token\n    [Timestamp]\n    public byte[] RowVersion { get; set; }\n}\n\n/*\nEF Core Migration snippet (generated via 'dotnet ef migrations add AddRowVersionToTicket')\nThe example below is generic. For SQL Server the column type is 'rowversion'; for Oracle you'll need a compatible column (e.g. RAW(8) or NUMBER) and coordinate with your DBA.\n*/\nmigrationBuilder.AddColumn<byte[]>(\n    name: \"RowVersion\",\n    table: \"Tickets\",\n    type: \"rowversion\", // <- change to correct type for your RDBMS\n    rowVersion: true,\n    nullable: true);\n",
      "notes": [
        "In SQL Server: [Timestamp] / rowversion works out of the box.",
        "In Oracle: there is no SQL Server rowversion; choose RAW(8) or NUMBER and mark as concurrency token (In OnModelCreating: builder.Property(t => t.RowVersion).IsRowVersion().HasColumnType(\"RAW(8)\"); or use .IsConcurrencyToken();)",
        "Handle DbUpdateConcurrencyException when SaveChangesAsync() fails due to concurrent edit."
      ]
    },
    {
      "id": "C04",
      "title": "Handling DbUpdateConcurrencyException (example)",
      "filename": "Services/TicketRepository.cs",
      "language": "csharp",
      "snippet": "try\n{\n    await _dbContext.SaveChangesAsync();\n}\ncatch (DbUpdateConcurrencyException ex)\n{\n    // Simple pattern: reload and inform user\n    foreach (var entry in ex.Entries)\n    {\n        if (entry.Entity is Ticket)\n        {\n            var databaseEntry = await entry.GetDatabaseValuesAsync();\n            if (databaseEntry == null)\n            {\n                throw new InvalidOperationException(\"The ticket was deleted by another user.\");\n            }\n            else\n            {\n                var databaseValues = databaseEntry.ToObject();\n                // Option: merge, show diff to user, or overwrite\n                throw new InvalidOperationException(\"The ticket has been modified by another user. Please reload and try again.\");\n            }\n        }\n    }\n    throw;\n}"
    },
    {
      "id": "C05",
      "title": "Serilog setup (WPF / desktop) with rolling files and Microsoft ILogger integration",
      "filename": "Program.cs or App.xaml.cs",
      "language": "csharp",
      "snippet": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Serilog;\n\npublic static class Program\n{\n    [STAThread]\n    public static void Main()\n    {\n        Log.Logger = new LoggerConfiguration()\n            .MinimumLevel.Debug()\n            .Enrich.FromLogContext()\n            .Enrich.WithProperty(\"Application\", \"TicketManager\")\n            .WriteTo.Console()\n            .WriteTo.File(\"logs/log-.txt\", rollingInterval: RollingInterval.Day, retainedFileCountLimit: 14)\n            .CreateLogger();\n\n        try\n        {\n            Log.Information(\"Starting application\");\n            var host = Host.CreateDefaultBuilder()\n                .UseSerilog() // integrates Serilog with Microsoft.Extensions.Logging\n                .ConfigureServices((context, services) =>\n                {\n                    // register services, viewmodels, dbcontext...\n                })\n                .Build();\n\n            var app = new App();\n            app.InitializeComponent();\n            app.Run();\n        }\n        catch (Exception ex)\n        {\n            Log.Fatal(ex, \"Application failed to start\");\n            throw;\n        }\n        finally\n        {\n            Log.CloseAndFlush();\n        }\n    }\n}",
      "notes": [
        "Consider adding sinks: Seq (WriteTo.Seq), ElasticSearch, Azure Application Insights depending on infra.",
        "Include environment and version as enricher: .Enrich.WithProperty(\"Version\", appVersion).",
        "For production, avoid logging PII and sensitive data."
      ]
    }
  ]
}